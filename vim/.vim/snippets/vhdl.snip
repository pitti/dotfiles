# Case statement
snippet case
	case ${1:expression} is
	  when ${2:choices} =>
	    ${3:--sequential statement(s)};
	  when ${4:choice2} =>
	    ${5:--sequential statement(s)};
	  ${6:--...}
	end case;

# Component declaration
snippet comp
	component ${1:identifier} is
	  port (
	    ${2:--I/O}
	  );
	end component $1;
# Component instantiation
snippet compinst
	$1_inst : ${1:--component name}
	  port map (
	    ${2:-- component_port => port_association,}
	  );

# Constant declaration
snippet const
	constant ${1:NAME} : ${2:type} := ${3:value};${4}

# D Flip Flop process
snippet ff
	process(${1:clk}) is
	begin
	  if (rising_edge($1)) then
	    ${2:sigR} <= ${3:sig};
	  end if;
	end process;

# D Flip Flop process with asynch. reset
snippet ffr
	process(${1:clk}, ${2:rst}) is
	begin
	  if ($2 = ${3:'0'}) then
	    ${4:sigR} <= ${5:'0'};
	  elsif (rising_edge($1)) then
	    $4 <= ${6:sig};
	  end if;
	end process;

# D Flip Flop process with asynch. reset and clock enable
snippet ffre
	process(${1:clk}, ${2:rst}) is
	begin
	  if ($2 = ${3:'0'}) then
	    ${4:sigR} <= ${5:'0'};
	  elsif (rising_edge($1)) then
	    if (${6:clkEn} = ${7:'1'}) then
	      $4 <= ${8:sig};
	    end if;
	  end if;
	end process;

# Entity declaration (no generic)
snippet ent
	entity ${1:<ent_name>} is
	  port (
	    ${2:--I/O}
	  );
	end entity $1;
	
	architecture ${3:rtl} of $1 is
	
	begin
	  ${4}
	end $3;

# If Condition
snippet if
	if (${1:--condition}) then
	  ${2:--do something};
	end if;
# Else if...
snippet ei
	elsif (${1:--condition}) then
	  ${2:--do something else};
# Else
snippet el
	else
	  ${1:--do something else};

# library ieee
snippet lib
	library ieee;  use ieee.${1:std_logic_1164}.all;
	               use ieee.${2:numeric_std}.all;${3}

# Process (plain)
snippet proc
	${1:proc name} : process is
	begin
	  ${2:--sequential statements;}
	end process $1;

# Signal declaration
snippet sig
	signal ${1:name}  : ${2:type};${3}

# std_logic;
snippet sl
	std_logic;${1}

# std_logic_vector(xx downto 0);
snippet slv
	std_logic_vector(${1:xx} downto ${2:0});${3}

# Type Declaration
snippet td
	type ${1:identifier} is ${2:definition};${3}
# Subtype Declaration
snippet st
	subtype ${1:identifier} is ${2:subtype indication};${3}

